import { Directive, DoCheck, Input, OnInit, TemplateRef, ViewContainerRef } from '@angular/core';
import { TextTemplate } from "../models/text-template";
import { TextComponent } from "../components/text/text.component";
import { PlaceholderIndex } from "../models/placeholder-index";

@Directive({
  selector: '[templatedText]'
})
export class TemplatedTextDirective implements OnInit, DoCheck {

  // #region Fields

  /**
   * Queue holding the {@link TextTemplate}s generated by the respective directive.
   * @private
   */
  private textTemplateQueue: Array<TextTemplate> = [];

  /**
   * Associated the placeholders with their prepared index within the {@link ViewContainerRef}.
   * @private
   */
  private placeholderIndices: PlaceholderIndex[] = [];

  // #endregion

  // #region Properties

  @Input('templatedText') set text(text: string | null) {
    if (text !== null) {
      this.prepareView(text);
    }
  }

  // #endregion

  // #region Constructors

  /**
   * Initializes a new instance of the {@link TemplatedTextDirective}.
   * @param viewContainerRef {@link ViewContainerRef} for the container used to render the templated string.
   * @param templateRef {@link TemplateRef} of the container, where all {@link TextTemplateDirective}s are contained.
   */
  constructor(
    private viewContainerRef: ViewContainerRef,
    private templateRef: TemplateRef<any>
  ) {
  }

  // #endregion

  // #region Methods

  /**
   * Enqueues a {@link TextTemplate} generated by the respective directives.
   * @param textTemplate {@link TextTemplate} referring to the template to render for a given placeholder.
   */
  enqueue(textTemplate: TextTemplate) {
    this.textTemplateQueue.push(textTemplate);
  }

  /**
   * Clears the old view and analyzes the new templated text for subsequent rendering.
   * @private
   */
  private prepareView(text: string) {
    const matches = [...text.matchAll(/{([A-z0-9_\-]+)}/g)];

    this.viewContainerRef.clear();
    this.viewContainerRef.createEmbeddedView(this.templateRef);

    this.textTemplateQueue = [];
    this.placeholderIndices = [];

    let previousIndex = 0;

    // NOTE: This index starts at 1 as initializing the viewContainerRef with the templateRef counts as the first component!
    let componentIndex = 1;

    if (matches.length > 0) {
      for (let i = 0; i < matches.length; i++) {
        const match = matches[i];

        if (match.index !== undefined) {

          if (match.index > previousIndex) {
            this.createText(text.substring(previousIndex, match.index));
            componentIndex++;
          }

          this.placeholderIndices.push({
            placeholder: match[1],
            index: componentIndex
          });

          this.createText(match[0]);
          componentIndex++;

          previousIndex = match.index + match[0].length;
        }

        if (i == matches.length - 1) {
          const remainder = text.substring(previousIndex);

          if(remainder.length > 0) {
            this.createText(text.substring(previousIndex));
            componentIndex++;
          }
        }
      }
    } else {
      this.createText(text);
    }
  }

  /**
   * Adds a {@link TextComponent} to the {@link ViewContainerRef}.
   * @param text Text to display within the {@link TextComponent}.
   * @private
   */
  private createText(text: string) {
    let viewRef = this.viewContainerRef.createComponent(TextComponent);

    viewRef.instance.text = text;
  }

  /**
   * Renders the view on init.
   */
  ngOnInit() {
    this.viewContainerRef.createEmbeddedView(this.templateRef);
  }

  /**
   * Processes the {@link TextTemplate} queue.
   */
  ngDoCheck() {
    if (this.placeholderIndices.length > 0) {
      for (let textTemplate of this.textTemplateQueue) {
        let placeholderIndices = this.placeholderIndices.filter(placeholderIndex => placeholderIndex.placeholder == textTemplate.placeholder);

        for (let placeholderIndex of placeholderIndices) {
          this.viewContainerRef.remove(placeholderIndex.index);
          this.viewContainerRef.createEmbeddedView(textTemplate.templateRef, null, placeholderIndex.index);
        }
      }

      this.textTemplateQueue = [];
    }
  }

  // #endregion

}
