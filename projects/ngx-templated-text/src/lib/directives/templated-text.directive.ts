import { Directive, DoCheck, Input, OnDestroy, OnInit, TemplateRef, ViewContainerRef } from '@angular/core';
import { TextTemplate } from "../models/text-template";
import { Subject, takeUntil } from "rxjs";
import { TextComponent } from "../components/text/text.component";

@Directive({
  selector: '[templatedText]'
})
export class TemplatedTextDirective implements OnInit, OnDestroy, DoCheck {

  // #region Fields

  /**
   * Clean way for unsubscribing.
   * @private
   */
  private ngUnsubscribe: Subject<void> = new Subject;


  /**
   * Queue holding the {@link TextTemplate}s generated by the respective directive.
   * @private
   */
  private textTemplateQueue: Array<TextTemplate> = [];

  /**
   * Associated the placeholders with their prepared index within the {@link ViewContainerRef}.
   * @private
   */
  private placeholderIndices: [string, number][] = [];

  // #endregion

  // #region Properties

  @Input('templatedText') set text(text: string | null) {
    if (text !== null) {
      this.prepareView(text);
    }
  }

  // #endregion

  // #region Constructors

  constructor(
    private viewContainerRef: ViewContainerRef,
    private templateRef: TemplateRef<any>
  ) {
  }

  // #endregion

  // #region Methods

  /**
   * Enqueues a {@link TextTemplate} generated by the respective directives.
   * @param textTemplate {@link TextTemplate} referring to the template to render for a given placeholder.
   */
  enqueue(textTemplate: TextTemplate) {
    this.textTemplateQueue.push(textTemplate);
  }

  /**
   * Clears the old view and analyzes the new templated text for subsequent rendering.
   * @private
   */
  private prepareView(text: string) {
    const matches = [...text.matchAll(/{([A-z0-9_\-]+)}/g)];

    this.viewContainerRef.clear();
    this.viewContainerRef.createEmbeddedView(this.templateRef);

    this.placeholderIndices = [];

    let previousIndex = 0;

    // NOTE: This index starts at 1 as initializing the viewContainerRef with the templateRef counts as the first component!
    let componentIndex = 1;

    if (matches.length > 0) {
      for (let i = 0; i < matches.length; i++) {
        const match = matches[i];

        if (match.index) {
          if (match.index! > previousIndex) {
            this.createText(text.substring(previousIndex, match.index));
            componentIndex++;
          }

          this.placeholderIndices.push([match[1], componentIndex]);

          this.createText(match[0]);
          componentIndex++;

          previousIndex = match.index + match[0].length;
        }

        if (i == matches.length - 1) {
          this.createText(text.substring(previousIndex));
          componentIndex++;
        }
      }
    } else {
      this.createText(text);
    }
  }

  /**
   * Adds a {@link TextComponent} to the {@link ViewContainerRef}.
   * @param text Text to display within the {@link TextComponent}.
   * @private
   */
  private createText(text: string) {
    let viewRef = this.viewContainerRef.createComponent(TextComponent);

    viewRef.instance.text = text;
  }


  /**
   * Renders the view on init.
   */
  ngOnInit() {
    this.viewContainerRef.createEmbeddedView(this.templateRef);
  }

  /**
   * Processes the {@link TextTemplate} queue.
   */
  ngDoCheck() {
    if(this.placeholderIndices.length > 0){
      for(let textTemplate of this.textTemplateQueue){
        let placeholderIndicies = this.placeholderIndices.filter(placeholderIndex=> placeholderIndex[0] == textTemplate.placeholder);

        for(let placeholderIndex of placeholderIndicies){
          this.viewContainerRef.remove(placeholderIndex[1]);
          this.viewContainerRef.createEmbeddedView(textTemplate.templateRef, null, placeholderIndex[1]);
        }
      }

      this.textTemplateQueue = [];
    }
  }

  /**
   * Cleanup.
   */
  ngOnDestroy() {
    this.ngUnsubscribe.next();
    this.ngUnsubscribe.complete();
  }

  // #endregion

}
